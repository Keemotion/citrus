

                                  ~* Citrus *~

                          Parsing Expressions for Ruby


Citrus is a compact and powerful parsing library for Ruby that combines the
elegance and expressiveness of the language with the simplicity and power of
parsing expression grammars.


  ** Installation **


Via RubyGems:

    $ sudo gem install citrus

From a local copy:

    $ git clone git://github.com/mjijackson/citrus.git
    $ cd citrus
    $ rake package && sudo rake install


  ** Background **


In order to be able to use Citrus effectively, you must first understand a few
basic concepts, namely, grammars, rules, and matches.

  * Grammars *

A grammar is a system of rules that define the structure of a language. Citrus
uses a type of grammar known as a parsing expression grammar (PEG). Although
PEG's are a relatively recent addition to the field of language recognition,
many grammar authors have found them to be a very powerful tool for grammar
creation due to their simplicity and ease of maintenance.

Citrus implements grammars as Ruby modules. Grammar modules have module-level
(or class-level) methods that assist the user in defining the rules of the
grammar, among other things.

  * Rules *

Each grammar has a finite set of rules that it uses to generate matches on some
input string. Rules come in two flavors: terminal and nonterminal.

Terminal rules match some sequence of characters in the input. Citrus currently
supports two types of terminals: strings and regular expressions. Strings match
based on their length and regular expressions match using Regexp#match. When a
terminal rule matches, it creates a new Match object that contains the portion
of the input that matched and its offset in the input string. Matches that are
generated by regular expression terminals may contain captures that the user can
retrieve later, during evaluation.

Nonterminals are wrappers for other rules, both terminal and nonterminal. They
use the rules they contain to determine whether or not they match on the input.

  * Matches *

Matches are created when rules match on the input. They are organized into a
tree structure where a match may contain any number of sub-matches. When a match
is created by a terminal, it will not contain any sub-matches because a terminal
may not contain any other rules. However, certain types of nonterminals may
create matches with sub-matches if, for example, they contain multiple rules
that all match in sequence.

Matches have several useful methods that enable them to be queried and compared
easily. They may also be extended with custom modules that provide further
semantic meaning.


  ** Usage **


Citrus grammars may be composed in one of two ways: using pure Ruby or Citrus'
own PEG format. The syntax between the two is very similar, but there is a small
trade-off. Both methods are discussed in detail below.


  * Using Ruby *

Citrus grammars may be defined entirely in Ruby. While this usage is a bit more
verbose than the traditional approach to writing PEG's, it's not too far off.
Due to the flexibility of the Ruby language, Citrus' Ruby syntax for defining
grammars is actually able to mimic the PEG notation very closely.

The primary advantage of defining your grammar in Ruby is that Citrus does not
need to do any special parsing or evaluating of your code. All that is handled
by the Ruby interpreter, so it can operate as fast as Ruby can. This may be an
advantage if your code runs in short-running processes.

You can create a new Citrus grammar in one of two ways: 1) create a new module
that includes Citrus::Grammar or 2) use Citrus::Grammar#new. The following two
snippets illustrate both methods. They are equivalent.

    module MyGrammar
      include Citrus::Grammar
    end

    MyGrammar = Citrus::Grammar.new

Citrus defines a set of helper methods for grammar and rule creation in the
Citrus::GrammarMethods module. New grammar modules extend this module
automatically.

Rules are added to a grammar using the `rule' method, e.g.:

    module Calculator
      include Citrus::Grammar

      rule :digit, /[0-9]/

      rule :number do
        one_or_more(:digit)
      end
    end

There are several things to note about the example above. First, the `rule'
method takes a variable length argument list. The first argument is the name
of the rule. A grammar may only contain one rule with a given name, although
it may inherit rules of the same name from another grammar (more on that later).
If a block is provided, the return value of the block is used as the "rule"
value, otherwise it may simply be the second parameter.

Secondly, rules in a grammar may be referenced from within other rules using
the symbol that represents their name. In this example, the `number' rule is
defined as one or more digits. However, it doesn't actually specify what a digit
is. Instead, it references the `digit' rule which already specifies that a digit
is any character in the range `0-9'.

Third, the `number' rule uses a sugar method from GrammarMethods (`one_or_more')
to specify that one or more digits is a number. See the documentation for the
GrammarMethods module for more information on the sugar methods that are
available. Since rules are defined within the module body, any of these methods
is available when defining grammars.




  * Using PEG *


Citrus grammars may also be defined using a variation of traditional PEG
notation. Citrus' PEG format strikes a compromise between the traditional
notation and Ruby syntax. The major advantage of composing a grammar using PEG
notation is that it is easier to read than Ruby and should already be relatively
familiar to people who have worked with other PEG formats.

The disadvantage is that Citrus must parse, and evaluate the grammar file before
it can be used. However, this only takes a fraction of a second and may not be a
significant detriment in long-running environments like servers because the
grammar will only be evaluated once, at startup.

Citrus PEG's are stored in files with the `.citrus' extension.


  ** License **


Copyright 2010 Michael Jackson

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
